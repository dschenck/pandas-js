import * as utils from '../core/utils'

describe('Determine types', () => {
    test('as strings', ()=> {
        expect(utils.isString('')).toBe(true)
        expect(utils.isString(new String(''))).toBe(true)
        expect(utils.isString('x')).toBe(true)
        expect(utils.isString(new String('x'))).toBe(true)
        expect(utils.isString(1)).toBe(false)
        expect(utils.isString(0)).toBe(false)
        expect(utils.isString(3/4)).toBe(false)
        expect(utils.isString()).toBe(false)
        expect(utils.isString(false)).toBe(false)
        expect(utils.isString(true)).toBe(false)
        expect(utils.isString(null)).toBe(false)
        expect(utils.isString(NaN)).toBe(false)
        expect(utils.isString(Infinity)).toBe(false)
        expect(utils.isString(-Infinity)).toBe(false)
        expect(utils.isString(undefined)).toBe(false)
        expect(utils.isString({})).toBe(false)
        expect(utils.isString({x:1})).toBe(false)
        expect(utils.isString([])).toBe(false)
        expect(utils.isString(["A","B"])).toBe(false)
    })
    test('as numbers', ()=> {
        expect(utils.isNumber('')).toBe(false)
        expect(utils.isNumber(new String(''))).toBe(false)
        expect(utils.isNumber('x')).toBe(false)
        expect(utils.isNumber(new String('x'))).toBe(false)
        expect(utils.isNumber(1)).toBe(true)
        expect(utils.isNumber(0)).toBe(true)
        expect(utils.isNumber(3/4)).toBe(true)
        expect(utils.isNumber(new Number(3.14))).toBe(true)
        expect(utils.isNumber(NaN)).toBe(true)
        expect(utils.isNumber(Infinity)).toBe(true)
        expect(utils.isNumber(-Infinity)).toBe(true)
        expect(utils.isNumber()).toBe(false)
        expect(utils.isNumber(false)).toBe(false)
        expect(utils.isNumber(true)).toBe(false)
        expect(utils.isNumber(null)).toBe(false)
        expect(utils.isNumber(undefined)).toBe(false)
        expect(utils.isNumber({})).toBe(false)
        expect(utils.isNumber({x:1})).toBe(false)
        expect(utils.isNumber([])).toBe(false)
        expect(utils.isNumber(["A","B"])).toBe(false)
    })
    test('as boolean', ()=> {
        expect(utils.isBoolean('')).toBe(false)
        expect(utils.isBoolean(new String(''))).toBe(false)
        expect(utils.isBoolean('x')).toBe(false)
        expect(utils.isBoolean(new String('x'))).toBe(false)
        expect(utils.isBoolean(1)).toBe(false)
        expect(utils.isBoolean(0)).toBe(false)
        expect(utils.isBoolean(3/4)).toBe(false)
        expect(utils.isBoolean(NaN)).toBe(false)
        expect(utils.isBoolean(Infinity)).toBe(false)
        expect(utils.isBoolean(-Infinity)).toBe(false)
        expect(utils.isBoolean()).toBe(false)
        expect(utils.isBoolean(false)).toBe(true)
        expect(utils.isBoolean(true)).toBe(true)
        expect(utils.isBoolean(null)).toBe(false)
        expect(utils.isBoolean(undefined)).toBe(false)
        expect(utils.isBoolean({})).toBe(false)
        expect(utils.isBoolean({x:1})).toBe(false)
        expect(utils.isBoolean([])).toBe(false)
        expect(utils.isBoolean(["A","B"])).toBe(false)
    })
})

describe('test values for definition', () => {
    test('if value is determined', ()=> {
        expect(utils.isDefined('')).toBe(true)
        expect(utils.isDefined(new String(''))).toBe(true)
        expect(utils.isDefined('x')).toBe(true)
        expect(utils.isDefined(new String('x'))).toBe(true)
        expect(utils.isDefined(1)).toBe(true)
        expect(utils.isDefined(0)).toBe(true)
        expect(utils.isDefined(3/4)).toBe(true)
        expect(utils.isDefined()).toBe(false)
        expect(utils.isDefined(false)).toBe(true)
        expect(utils.isDefined(true)).toBe(true)
        expect(utils.isDefined(null)).toBe(false)
        expect(utils.isDefined(NaN)).toBe(false)
        expect(utils.isDefined(Infinity)).toBe(false)
        expect(utils.isDefined(-Infinity)).toBe(false)
        expect(utils.isDefined(undefined)).toBe(false)
        expect(utils.isDefined({})).toBe(true)
        expect(utils.isDefined({x:1})).toBe(true)
        expect(utils.isDefined([])).toBe(true)
        expect(utils.isDefined(["A","B"])).toBe(true)
    })
    test('if value is missing', ()=> {
        expect(utils.isNA('')).toBe(false)
        expect(utils.isNA(new String(''))).toBe(false)
        expect(utils.isNA('A')).toBe(false)
        expect(utils.isNA(new String('x'))).toBe(false)
        expect(utils.isNA(1)).toBe(false)
        expect(utils.isNA(0)).toBe(false)
        expect(utils.isNA(3/4)).toBe(false)
        expect(utils.isNA()).toBe(true)
        expect(utils.isNA(true)).toBe(false)
        expect(utils.isNA(false)).toBe(false)
        expect(utils.isNA(null)).toBe(true)
        expect(utils.isNA(NaN)).toBe(true)
        expect(utils.isNA(Infinity)).toBe(true)
        expect(utils.isNA(-Infinity)).toBe(true)
        expect(utils.isNA(undefined)).toBe(true)
        expect(utils.isNA({})).toBe(false)
        expect(utils.isNA({x:1})).toBe(false)
        expect(utils.isNA([])).toBe(false)
        expect(utils.isNA(["A","B"])).toBe(false)
    })
})


describe('test for numeric values', () => {
    test('if value is numeric', ()=> {
        expect(utils.isNumeric('')).toBe(false)
        expect(utils.isNumeric(new String(''))).toBe(false)
        expect(utils.isNumeric('x')).toBe(false)
        expect(utils.isNumeric(new String('x'))).toBe(false)
        expect(utils.isNumeric(1)).toBe(true)
        expect(utils.isNumeric(0)).toBe(true)
        expect(utils.isNumeric(3/4)).toBe(true)
        expect(utils.isNumeric()).toBe(false)
        expect(utils.isNumeric(true)).toBe(true)
        expect(utils.isNumeric(false)).toBe(true)
        expect(utils.isNumeric(null)).toBe(false)
        expect(utils.isNumeric(NaN)).toBe(false)
        expect(utils.isNumeric(Infinity)).toBe(false)
        expect(utils.isNumeric(-Infinity)).toBe(false)
        expect(utils.isNumeric(undefined)).toBe(false)
        expect(utils.isNumeric({})).toBe(false)
        expect(utils.isNumeric({x:1})).toBe(false)
        expect(utils.isNumeric([])).toBe(false)
        expect(utils.isNumeric(["A","B"])).toBe(false)
    })

    test('if value is non-numeric (not a number)', ()=> {
        expect(utils.isNaN('')).toBe(true)
        expect(utils.isNaN(new String(''))).toBe(true)
        expect(utils.isNaN('x')).toBe(true)
        expect(utils.isNaN(new String('x'))).toBe(true)
        expect(utils.isNaN(1)).toBe(false)
        expect(utils.isNaN(0)).toBe(false)
        expect(utils.isNaN(3/4)).toBe(false)
        expect(utils.isNaN()).toBe(true)
        expect(utils.isNaN(true)).toBe(false)
        expect(utils.isNaN(false)).toBe(false)
        expect(utils.isNaN(null)).toBe(true)
        expect(utils.isNaN(NaN)).toBe(true)
        expect(utils.isNaN(Infinity)).toBe(true)
        expect(utils.isNaN(-Infinity)).toBe(true)
        expect(utils.isNaN(undefined)).toBe(true)
        expect(utils.isNaN({})).toBe(true)
        expect(utils.isNaN({x:1})).toBe(true)
        expect(utils.isNaN([])).toBe(true)
        expect(utils.isNaN(["A","B"])).toBe(true)
    })
})

